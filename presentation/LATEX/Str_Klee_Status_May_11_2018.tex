%%%%%%%%%%%%%%%%%%%%%%%%%%
% document class: beamer %
%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass{beamer}

%%%%%%%%%%%%
% PACKAGES %
%%%%%%%%%%%%
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{multirow}
\hypersetup{colorlinks=true,urlcolor=blue}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% no navigation bars please %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setbeamertemplate{footline}[frame number]{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% no navigation symbols please %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setbeamertemplate{navigation symbols}{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% no footers at all please %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setbeamertemplate{footline}{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% center the title please %
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setbeamertemplate{frametitle}[default][center]

%%%%%%%%%%%%%%%%%%
% begin document %
%%%%%%%%%%%%%%%%%%
\begin{document}

%%%%%%%%%
% title %
%%%%%%%%%
\title{Strings Enhanced Symbolic Execution}   

%%%%%%%%%%
% author %
%%%%%%%%%%
\author{Treating Strings as ADTs in a KLEE/Z3 framework}

%%%%%%%%%%%%
% date ... %
%%%%%%%%%%%%
\date{\today} 

%%%%%%%%%%%%%
% frame ... %
%%%%%%%%%%%%%
\frame{\titlepage} 

%\frame{\frametitle{Table of contents}\tableofcontents} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SECTION :: Background %
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Section Background} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Frame Title :: Background %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frame{\frametitle{Background}
%%%%%%%%%%%%%%%%%%
% Items :: Begin %
%%%%%%%%%%%%%%%%%%
\begin{itemize}
\item
String intensive programs are abundant,
and analyzing them naively in a symbolic execution framework
is hard: string library code is analyzed as a bundle with
application code, spawning a huge amount of irrelevent states. 
\item
String SMT solvers allow a direct encoding of string library
code to SMT formulae, thus reducing dramatically the number
of explored states.
\item
Several string solvers exist:
\href{https://people.csail.mit.edu/akiezun/issta54-kiezun.pdf}{Hampi},
\href{http://webblaze.cs.berkeley.edu/2010/kudzu/kudzu.pdf}{Kaluza},
\href{https://pdfs.semanticscholar.org/33b1/576783490f94fe28f40570d6bf396f6369a4.pdf}{Pisa},
\href{http://www.cs.ucsb.edu/~bultan/publications/tacas10.pdf}{Stranger}
\href{https://github.com/OrenGitHub/klee/issues/22}{CVC4},
\href{https://www.comp.nus.edu.sg/~joxan/papers/S3.pdf}{S3},
\href{https://ece.uwaterloo.ca/~vganesh/Publications_files/vg2017-Z3str3-FMCAD2017.pdf}{Z3str3},
and they have been used (to some extent) to analyze SQL querries and
programs in Java, JavaScript and PHP.
\item
str.KLEE enables symbolic execution of arbitrary C programs,
which are (considerably) more widespread than previously mentioned
PL, and have a more complicated semantics.
It uses KLEE together with Z3, state-of-the-art SE and solver.
%%%%%%%%%%%%%%%%
% Items :: End %
%%%%%%%%%%%%%%%%
\end{itemize}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SECTION :: Implementation (High Level) Description %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation (High Level) Description} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Frame Title :: Implementation (High Level) Description %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frame{\frametitle{Implementation (High Level) Description}
%%%%%%%%%%%%%%%%%%
% Items :: Begin %
%%%%%%%%%%%%%%%%%%
\begin{itemize}
\item
Resolving occurrences of program string variables is
not trivial in C, which is weakly typed, and allows
taking the memory location of stored variables:
msg$\rightarrow$contents = (void *) $\&$buf;
\item
We use the term abstract buffers to denote the corresponding solver string variables.
As the program modifies strings with writes, strcpy etc.
abstrct buffers accumulate these changes by keeping consecutive
versions for abstract buffers.
\item
Using a many sorted solver inevitably introduces sort conversion issues.
Suppose that a bitvector is added to an integer:
(i $<<$ 5) + strlen( msg )
and it is sound to do this addition in both bitvector and integer domains.
Which expression should be converted? we say: whichever is faster!
%%%%%%%%%%%%%%%%
% Items :: End %
%%%%%%%%%%%%%%%%
\end{itemize}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SECTION :: Accelerations %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Accelerations} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Frame Title :: Accelerations %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frame{\frametitle{Accelerations List}
%%%%%%%%%%%%%%%%%%
% Items :: Begin %
%%%%%%%%%%%%%%%%%%
\begin{itemize}
\item
Context Aware Sorts
\begin{itemize}
\item ((*s) == 'a') vs. ((*s) $<<$ 5)
\end{itemize}
\item
Tailored String Semantics
\begin{itemize}
\item int strcmp(s1,s2) $\rightarrow$ bool strcmp(s1,s2)
\item char *strchr(s,c) $\rightarrow$ bool strchr(s,c)
\end{itemize}
\item
Solver Performance Driven Query Rewriting
\begin{itemize}
\item str.indexof $\rightarrow$ str.contains
\item str.indexof $\rightarrow$ str.len
\item automatic deducing of query invariants
\end{itemize}
\item
Reducing Number of States with C to C translations:\\
char *f(char *d,char *s)
$\{$
while (*d++ = *s++);
$\}$
return d;
$\rightarrow$ strcpy(d,s); return d+strlen(src);
\item
Caching reads/writes.
\item
Reducing number of generated abtract buffer versions.
\item

%%%%%%%%%%%%%%%%
% Items :: End %
%%%%%%%%%%%%%%%%
\end{itemize}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SECTION :: Accelerations %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Accelerations} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Frame Title :: Accelerations %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frame{\frametitle{Accelerations :: Context Aware Sorts}
%%%%%%%%%%%%%%%%%%
% Items :: Begin %
%%%%%%%%%%%%%%%%%%
\begin{itemize}
\item
Sort conversions are expansive, and in some cases they can be avoided altogether.
Think of the following examples:\\
~ ~ ~ ~if ((*s) == ' ')           $\{$ s++; $\}$ \\
~ ~ ~ ~if (((*s) $<<$ 3) $<$ 100) $\{$ s++; $\}$ \\
Since the returned value from (*s) has a string sort,
then in order to shift it left, it needs to be converted to a bit vector.
In constrast, if it is simply compared to the space character,
then it needs not be converted at all.
\item
A simple pre processing of the program can easily identify locations
where such conversions are not needed.
%%%%%%%%%%%%%%%%
% Items :: End %
%%%%%%%%%%%%%%%%
\end{itemize}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SECTION :: Accelerations %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Accelerations} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Frame Title :: Accelerations %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frame{\frametitle{Accelerations :: Tailored String Semantics}
%%%%%%%%%%%%%%%%%%
% Items :: Begin %
%%%%%%%%%%%%%%%%%%
\begin{itemize}
\item
The semantics of string library functions often contains more
details then actually needed by users.
For example, whenever two strings are compared with strcmp(s1,s2),
the returned value is either $0$ when they areidentical,
or the ascii difference between the first place of change is returned.
Almost all users simply ask whether the result is $0$ or not.
This gives a chance for a sound optimization, since it enables us
to use the native returned boolean from the solver, and ignore
the ascii difference since the program makes no use of this value.
\item
Similarly, some programs use strchr to simply check the existence of
a certain character in a string:

if (strchr( s, ' ')) $\{$ return -1; $\}$
%%%%%%%%%%%%%%%%
% Items :: End %
%%%%%%%%%%%%%%%%
\end{itemize}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SECTION :: Accelerations %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Accelerations} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Frame Title :: Accelerations %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frame{\frametitle{Accelerations :: Query Rewriting}
%%%%%%%%%%%%%%%%%%
% Items :: Begin %
%%%%%%%%%%%%%%%%%%
\begin{itemize}
\item
The semantics of string library functions often contains more
details then actually needed by users.
For example, whenever two strings are compared with strcmp(s1,s2),
the returned value is either $0$ when they areidentical,
or the ascii difference between the first place of change is returned.
Almost all users simply ask whether the result is $0$ or not.
This gives a chance for a sound optimization, since it enables us
to use the native returned boolean from the solver, and ignore
the ascii difference since the program makes no use of this value.
\item
Similarly, some programs use strchr to simply check the existence of
a certain character in a string:

if (strchr( s, ' ')) $\{$ return -1; $\}$
%%%%%%%%%%%%%%%%
% Items :: End %
%%%%%%%%%%%%%%%%
\end{itemize}
}

\end{document}
